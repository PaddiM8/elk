fn sel(container) => closure {
    let values = []
    for value in container: values | push(closure(value))

    values
}

let ending = "!"
let result = ["this", "is", "a", "test"]
    | sel => x: x + ending
    | sel => x: x + ending
assert(result[0] == "this!!")
assert(result[3] == "test!!")

let ints = ["1", "2"] | sel => &into::int
assert(ints[0] == 1)
assert(ints[1] == 2)

fn thing() => closure {
    closure()
}

thing =>: assert(true)

# independent closure
let f = &Fn => x: x + "!"
let result = f | call hi
assert(result == "hi!")

# nested closures
fn level1() => closure: closure("1")
fn level2() => closure: closure("2")
fn level3() => closure: closure("3")

level1 => a: {
    level2 => b: {
        level3 => c: assert(a + b + c == "123")
    }
}

# function reference
fn a(x): x + 1
assert(([1, 2, 3] | map => &a | join) == "234")
assert(([1, 2, 3] | iter::reduce => &op::mul) == 6)

fn b(x, y): x + y
assert(([1, 2, 3] | map => &b(10) | join ", ") == "11, 12, 13")
assert(([1, 2, 3] | map => &op::mul(3) | math::sum) == 18)
